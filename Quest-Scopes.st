Object subclass: #QEnvironment	instanceVariableNames: 'variableScope methodScope activations'	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!Object subclass: #ScopeInterface	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!ScopeInterface methodsFor: 'scope interface' stamp: 'jws 11/7/2022 10:13'!bind: aNameto: aValue	"Associate aName with aValue. If aName is already bound, signal QMultipleDeclaration."		self subclassResponsibility! !!ScopeInterface methodsFor: 'scope interface' stamp: 'jws 11/7/2022 10:12'!fetch: aName	"Return the value bound to this name if in scope. Otherwise signal QUndeclared."		self subclassResponsibility! !!ScopeInterface methodsFor: 'scope interface' stamp: 'jws 11/7/2022 10:14'!isInScope: aName	"Return true if aName has a binding in scope."		self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScopeInterface class	instanceVariableNames: ''!!ScopeInterface class methodsFor: 'instance creation' stamp: 'jws 11/9/2022 10:19'!globalScope	^Scope new! !ScopeInterface subclass: #NullScope	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!NullScope methodsFor: 'scope interface' stamp: 'jws 11/9/2022 10:34'!bind: aString to: anInteger 	QError signal: 'There are no bindings in the null scope!!'! !!NullScope methodsFor: 'scope interface' stamp: 'jws 11/9/2022 10:32'!fetch: aName	QUndeclared signal: aName	! !!NullScope methodsFor: 'scope interface' stamp: 'jws 11/9/2022 10:35'!isInScope: aName	^false	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NullScope class	instanceVariableNames: 'default'!!NullScope class methodsFor: 'instance creation' stamp: 'jws 11/4/2022 10:53'!new	NotImplemented signal: 'NullScope is a singleton'! !!NullScope class methodsFor: 'accessing' stamp: 'jws 11/4/2022 10:52'!default	default isNil ifTrue: [default := super new].	^default! !ScopeInterface subclass: #Scope	instanceVariableNames: 'outerScope bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!Scope methodsFor: 'initialize-release' stamp: 'jws 11/9/2022 10:22'!initialize	super initialize.	outerScope := NullScope default.	bindings := Dictionary new.! !TestCase subclass: #TestEnvironment	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!TestEnvironment methodsFor: 'running' stamp: 'jws 11/10/2022 10:52'!testActivation	| firstActiveScope |	self assert: (self env globalScope == self env variableScope).	self env createActivation.	firstActiveScope := self env variableScope.	self assert: (self env activations size == 1).	self assert: (self env activations first == self env globalScope).	self deny: (self env globalScope == self env variableScope).	self assert: (self env variableScope outerScope == self env globalScope).	self env createActivation.	self assert: (self env activations size == 2).	self deny: (self env globalScope == self env variableScope).	self assert: (self env variableScope outerScope == self env globalScope).	self assert: (self env activations second == firstActiveScope).	self env destroyActivation.	self assert: (self env variableScope == firstActiveScope).	self env destroyActivation.	self assert: (self env variableScope == self env globalScope).		! !!TestEnvironment methodsFor: 'running' stamp: 'jws 11/9/2022 10:47'!testConstructor	self assert: (env variableScope notNil).	self assert: (env variableScope class name = #Scope).	self assert: (env methodScope notNil).	self assert: (env methodScope class name = #Scope).	self assert: (env methodScope ~= env variableScope).	self assert: (env activations isEmpty).! !!TestEnvironment methodsFor: 'running' stamp: 'jws 11/10/2022 10:32'!testVariableErrors	| aVar |	aVar := QVariable newBoolean.	self env bind: self varName variable: aVar.	self 		should: [self env bind: self varName variable: aVar]		raise: QMultiplyDeclared! !!TestEnvironment methodsFor: 'running' stamp: 'jws 11/10/2022 10:33'!testVariableScope	| aVar bVar |	self deny: (self env isInVariableScope: self varName).	aVar := QVariable newBoolean.	self env bind: self varName variable: aVar.	self assert: (self env isInVariableScope: self varName).	bVar := self env fetchVariable: self varName.	self assert: (aVar == bVar).! !!TestEnvironment methodsFor: 'running' stamp: 'jws 11/10/2022 10:30'!varName	^ 'glasses'! !!TestEnvironment methodsFor: 'initialize-release' stamp: 'jws 11/9/2022 10:37'!setUp	super setUp.	env := QEnvironment new.! !!TestEnvironment methodsFor: 'initialize-release' stamp: 'jws 11/9/2022 10:38'!tearDown	env := nil.	super tearDown.! !!TestEnvironment methodsFor: 'accessing' stamp: 'jws 11/10/2022 10:26'!env	^ env! !!TestEnvironment methodsFor: 'accessing' stamp: 'jws 11/10/2022 10:26'!env: anObject	env := anObject! !TestCase subclass: #TestNullScope	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!TestNullScope methodsFor: 'running' stamp: 'jws 11/7/2022 10:10'!testInterface	| aScope |	aScope := NullScope default.	self		should: [aScope fetch: 'factorial']		raise: QUndeclared.	self 		should: [aScope bind: 'theAnswer' to: 42]		raise: QError.	self deny: (aScope isInScope: 'factorial').! !!TestNullScope methodsFor: 'running' stamp: 'jws 11/4/2022 10:46'!testSingleton	| scopeA scopeB |	scopeA := NullScope default.	scopeB := NullScope default.	self assert: (scopeA == scopeB).	self		should: [NullScope new]		raise: NotImplemented! !TestCase subclass: #TestScope	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Quest-Scopes'!!TestScope methodsFor: 'running' stamp: 'jws 11/7/2022 10:21'!testHappyPath	| aScope |	aScope := Scope new.	self deny: (aScope isInScope: 'xlerb').	aScope bind: 'xlerb' to: 'FORTH'.	self assert: (aScope isInScope: 'xlerb').	self assert: ((aScope fetch: 'xlerb') = 'FORTH').! !!TestScope methodsFor: 'running' stamp: 'jws 11/7/2022 10:25'!testMultiplyDeclared	| aScope |	aScope := Scope new.	aScope bind: 'xlerb' to: 1.	self		should: [aScope bind: 'xlerb' to: 2]		raise: QMultiplyDeclared! !!TestScope methodsFor: 'running' stamp: 'jws 11/9/2022 10:14'!testNestedScopes	| scopeA scopeB scopeC |	scopeA := ScopeInterface globalScope.	scopeB := ScopeInterface outerScope: scopeA.	scopeC := ScopeInterface outerScope: scopeB.	scopeC bind: 'onlyInC' to: 1.	self deny: (scopeA isInScope: 'onlyInC').	self deny: (scopeB isInScope: 'onlyInC').	self assert: (scopeC isInScope: 'onlyInC').	scopeA bind: 'declaredInA' to: 2.	self assert: (scopeA isInScope: 'declaredInA').	self assert: (scopeB isInScope: 'declaredInA').	self assert: (scopeC isInScope: 'declaredInA').	self assert: ((scopeC fetch: 'declaredInA') = 2).	scopeA bind: 'declaredInAC' to: 3.	scopeC bind: 'declaredInAC' to: 4.	self assert: ((scopeA fetch: 'declaredInAC') = 3).	self assert: ((scopeB fetch: 'declaredInAC') = 3).	self assert: ((scopeC fetch: 'declaredInAC') = 4).! !!TestScope methodsFor: 'running' stamp: 'jws 11/7/2022 10:23'!testUndeclared	| aScope |	aScope := Scope new.	self		should: [aScope fetch: 'xlerb']		raise: QUndeclared! !